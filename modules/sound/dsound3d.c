// 
// 	 Enemy Engaged RAH-66 Comanche Versus KA-52 Hokum
// 	 Copyright (C) 2000 Empire Interactive (Europe) Ltd,
// 	 677 High Road, North Finchley, London N12 0DA
// 
// 	 Please see the document LICENSE.TXT for the full licence agreement
// 
// 2. LICENCE
//  2.1 	
//  	Subject to the provisions of this Agreement we now grant to you the 
//  	following rights in respect of the Source Code:
//   2.1.1 
//   	the non-exclusive right to Exploit  the Source Code and Executable 
//   	Code on any medium; and 
//   2.1.2 
//   	the non-exclusive right to create and distribute Derivative Works.
//  2.2 	
//  	Subject to the provisions of this Agreement we now grant you the
// 	following rights in respect of the Object Code:
//   2.2.1 
// 	the non-exclusive right to Exploit the Object Code on the same
// 	terms and conditions set out in clause 3, provided that any
// 	distribution is done so on the terms of this Agreement and is
// 	accompanied by the Source Code and Executable Code (as
// 	applicable).
// 
// 3. GENERAL OBLIGATIONS
//  3.1 
//  	In consideration of the licence granted in clause 2.1 you now agree:
//   3.1.1 
// 	that when you distribute the Source Code or Executable Code or
// 	any Derivative Works to Recipients you will also include the
// 	terms of this Agreement;
//   3.1.2 
// 	that when you make the Source Code, Executable Code or any
// 	Derivative Works ("Materials") available to download, you will
// 	ensure that Recipients must accept the terms of this Agreement
// 	before being allowed to download such Materials;
//   3.1.3 
// 	that by Exploiting the Source Code or Executable Code you may
// 	not impose any further restrictions on a Recipient's subsequent
// 	Exploitation of the Source Code or Executable Code other than
// 	those contained in the terms and conditions of this Agreement;
//   3.1.4 
// 	not (and not to allow any third party) to profit or make any
// 	charge for the Source Code, or Executable Code, any
// 	Exploitation of the Source Code or Executable Code, or for any
// 	Derivative Works;
//   3.1.5 
// 	not to place any restrictions on the operability of the Source 
// 	Code;
//   3.1.6 
// 	to attach prominent notices to any Derivative Works stating
// 	that you have changed the Source Code or Executable Code and to
// 	include the details anddate of such change; and
//   3.1.7 
//   	not to Exploit the Source Code or Executable Code otherwise than
// 	as expressly permitted by  this Agreement.
// 



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "sound_internal.h"

#include "maths.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

LPDIRECTSOUND3DBUFFER dsound_get_3d_buffer ( LPDIRECTSOUNDBUFFER buffer )
{
/*
	LPDIRECTSOUND3DBUFFER
		buffer3d;

	HRESULT
		dsrval;

	dsrval = IDirectSoundBuffer_QueryInterface ( buffer, &IID_IDirectSound3DBuffer, &buffer3d );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to get the 3dbuffer interface: %s", get_dsound_error_message ( dsrval ) );

		return ( NULL );
	}

	return ( buffer3d );
	*/

	return ( NULL );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_is_3d_buffer ( LPDIRECTSOUNDBUFFER buffer )
{

	DSBCAPS
		caps;

	HRESULT
		dsrval;

	memset ( &caps, 0, sizeof ( caps ) );

	caps.dwSize = sizeof ( caps );

	dsrval = IDirectSoundBuffer_GetCaps ( buffer, &caps );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to get caps of the sound buffer: %s", get_dsound_error_message ( dsrval ) );
	}

	if ( caps.dwFlags & DSBCAPS_CTRL3D )
	{

		return ( TRUE );
	}
	else
	{

		return ( FALSE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_set_listener_3d_position ( vec3d *position )
{

	HRESULT
		dsrval;

	dsrval = IDirectSound3DListener_SetPosition ( d3dsound_listener, position->x, position->y, position->z, DS3D_DEFERRED );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to set position of 3d listener object: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_get_listener_3d_position ( vec3d *position )
{

	HRESULT
		dsrval;

	D3DVECTOR
		vector;

	dsrval = IDirectSound3DListener_GetPosition ( d3dsound_listener, &vector );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to get position of 3d listener object: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{

		position->x = vector.x;
		position->y = vector.y;
		position->z = vector.z;

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_set_listener_3d_velocity ( vec3d *velocity )
{

	HRESULT
		dsrval;

	dsrval = IDirectSound3DListener_SetVelocity ( d3dsound_listener, velocity->x, velocity->y, velocity->z, DS3D_DEFERRED );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to set velocity of 3d listener object: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_get_listener_3d_velocity ( vec3d *velocity )
{

	HRESULT
		dsrval;

	D3DVECTOR
		vector;

	dsrval = IDirectSound3DListener_GetVelocity ( d3dsound_listener, &vector );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to get velocity of 3d listener object: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{
	
		velocity->x = vector.x;
		velocity->y = vector.y;
		velocity->z = vector.z;

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_set_listener_3d_orientation ( vec3d *top, vec3d *front )
{

	HRESULT
		dsrval;

	dsrval = IDirectSound3DListener_SetOrientation ( d3dsound_listener,
																		front->x, front->y, front->z,
																		top->x, top->y, top->z, DS3D_DEFERRED );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to set orientation of 3d listener object: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_get_listener_3d_orientation ( vec3d *top, vec3d *front )
{

	HRESULT
		dsrval;

	D3DVECTOR
		front_vector,
		top_vector;

	dsrval = IDirectSound3DListener_GetOrientation ( d3dsound_listener, &front_vector, &top_vector );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to get orientation of 3d listener object: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{

		top->x = top_vector.x;
		top->y = top_vector.y;
		top->z = top_vector.z;

		front->x = front_vector.x;
		front->y = front_vector.y;
		front->z = front_vector.z;

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_set_listener_doppler_factor ( float factor )
{

	HRESULT
		dsrval;

	dsrval = IDirectSound3DListener_SetDopplerFactor ( d3dsound_listener, factor, DS3D_DEFERRED );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to set doppler factor of 3d listener object: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_get_listener_doppler_factor ( float *factor )
{

	HRESULT
		dsrval;

	dsrval = IDirectSound3DListener_GetDopplerFactor ( d3dsound_listener, factor );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to get doppler factor of 3d listener object: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_set_listener_rolloff_factor ( float factor )
{

	HRESULT
		dsrval;

	dsrval = IDirectSound3DListener_SetRolloffFactor ( d3dsound_listener, factor, DS3D_DEFERRED );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to set rolloff factor of 3d listener object: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_get_listener_rolloff_factor ( float *factor )
{

	HRESULT
		dsrval;

	dsrval = IDirectSound3DListener_GetRolloffFactor ( d3dsound_listener, factor );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to get rolloff factor of 3d listener object: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_set_buffer_3d_position ( LPDIRECTSOUND3DBUFFER buffer, vec3d *position )
{

	HRESULT
		dsrval;

	dsrval = IDirectSound3DBuffer_SetPosition ( buffer, position->x, position->y, position->z, DS3D_DEFERRED );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to set position of 3d buffer: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_get_buffer_3d_position ( LPDIRECTSOUND3DBUFFER buffer, vec3d *position )
{

	HRESULT
		dsrval;

	D3DVECTOR
		vector;

	dsrval = IDirectSound3DBuffer_GetPosition ( buffer, &vector );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to get position of 3d buffer: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{

		position->x = vector.x;
		position->y = vector.y;
		position->z = vector.z;

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_set_buffer_3d_velocity ( LPDIRECTSOUND3DBUFFER buffer, vec3d *velocity )
{

	HRESULT
		dsrval;

	dsrval = IDirectSound3DBuffer_SetVelocity ( buffer, velocity->x, velocity->y, velocity->z, DS3D_DEFERRED );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to set velocity of 3d buffer: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_get_buffer_3d_velocity ( LPDIRECTSOUND3DBUFFER buffer, vec3d *velocity )
{

	HRESULT
		dsrval;

	D3DVECTOR
		vector;

	dsrval = IDirectSound3DBuffer_GetVelocity ( buffer, &vector );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to get velocity of 3d buffer: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{
	
		velocity->x = vector.x;
		velocity->y = vector.y;
		velocity->z = vector.z;

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_set_buffer_3d_maximum_distance ( LPDIRECTSOUND3DBUFFER buffer, float distance )
{

	HRESULT
		dsrval;

	dsrval = IDirectSound3DBuffer_SetMaxDistance ( buffer, distance, DS3D_DEFERRED );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to set max distance of 3d buffer: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_get_buffer_3d_maximum_distance ( LPDIRECTSOUND3DBUFFER buffer, float *distance )
{

	HRESULT
		dsrval;

	dsrval = IDirectSound3DBuffer_GetMaxDistance ( buffer, distance );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to get max distance of 3d buffer: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_set_buffer_3d_minimum_distance ( LPDIRECTSOUND3DBUFFER buffer, float distance )
{

	HRESULT
		dsrval;

	dsrval = IDirectSound3DBuffer_SetMinDistance ( buffer, distance, DS3D_DEFERRED );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to set min distance of 3d buffer: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_get_buffer_3d_minimum_distance ( LPDIRECTSOUND3DBUFFER buffer, float *distance )
{

	HRESULT
		dsrval;

	dsrval = IDirectSound3DBuffer_GetMinDistance ( buffer, distance );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to get min distance of 3d buffer: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int dsound_commit_3d_settings ( void )
{

	HRESULT
		dsrval;

	dsrval = IDirectSound3DListener_CommitDeferredSettings ( d3dsound_listener );

	if ( dsrval != DS_OK )
	{

		debug_log ( "Unable to commit settings of 3d listener object: %s", get_dsound_error_message ( dsrval ) );

		return ( FALSE );
	}
	else
	{

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

