//
// 	 Enemy Engaged RAH-66 Comanche Versus KA-52 Hokum
// 	 Copyright (C) 2000 Empire Interactive (Europe) Ltd,
// 	 677 High Road, North Finchley, London N12 0DA
//
// 	 Please see the document LICENSE.TXT for the full licence agreement
//
// 2. LICENCE
//  2.1
//  	Subject to the provisions of this Agreement we now grant to you the
//  	following rights in respect of the Source Code:
//   2.1.1
//   	the non-exclusive right to Exploit  the Source Code and Executable
//   	Code on any medium; and
//   2.1.2
//   	the non-exclusive right to create and distribute Derivative Works.
//  2.2
//  	Subject to the provisions of this Agreement we now grant you the
// 	following rights in respect of the Object Code:
//   2.2.1
// 	the non-exclusive right to Exploit the Object Code on the same
// 	terms and conditions set out in clause 3, provided that any
// 	distribution is done so on the terms of this Agreement and is
// 	accompanied by the Source Code and Executable Code (as
// 	applicable).
//
// 3. GENERAL OBLIGATIONS
//  3.1
//  	In consideration of the licence granted in clause 2.1 you now agree:
//   3.1.1
// 	that when you distribute the Source Code or Executable Code or
// 	any Derivative Works to Recipients you will also include the
// 	terms of this Agreement;
//   3.1.2
// 	that when you make the Source Code, Executable Code or any
// 	Derivative Works ("Materials") available to download, you will
// 	ensure that Recipients must accept the terms of this Agreement
// 	before being allowed to download such Materials;
//   3.1.3
// 	that by Exploiting the Source Code or Executable Code you may
// 	not impose any further restrictions on a Recipient's subsequent
// 	Exploitation of the Source Code or Executable Code other than
// 	those contained in the terms and conditions of this Agreement;
//   3.1.4
// 	not (and not to allow any third party) to profit or make any
// 	charge for the Source Code, or Executable Code, any
// 	Exploitation of the Source Code or Executable Code, or for any
// 	Derivative Works;
//   3.1.5
// 	not to place any restrictions on the operability of the Source
// 	Code;
//   3.1.6
// 	to attach prominent notices to any Derivative Works stating
// 	that you have changed the Source Code or Executable Code and to
// 	include the details anddate of such change; and
//   3.1.7
//   	not to Exploit the Source Code or Executable Code otherwise than
// 	as expressly permitted by  this Agreement.
//



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "project.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//note: 	when converting data from .txt files generated by excel, turn PREPROCESS_DAT_FILES & DEBUG_MODULE on
//			when using new translation material for the first time, turn DEBUG_LANGUAGES on

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define BUFFER_SIZE 8192

#define DEBUG_MODULE 0

#define PREPROCESS_DAT_FILES 0

#define POSTPROCESS_DAT_FILES 0

#define DEBUG_LANGUAGES 0

#define NUM_ALPHABET_POINTERS 28

#define LANGUAGE_DIRECTORY "..\\common\\data\\language"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void initialise_alphabet_pointers (void);

static language_struct *initialise_translation (void);

static void insert_translation (language_struct *insert_me);

static void delete_translation (language_struct *delete_me);

static void initialise_language_file (FILE *fp);

static void validate_translation_database (void);

static int get_next_file_translation (FILE *file_ptr, char *buffer, int size);

#if PREPROCESS_DAT_FILES
	static void preprocess_language_file (FILE *fp, FILE *fp_out);

	static void preprocess_language_database (void);
#endif
	
char full_filename[256]; // LAST TRANSLATION FILE

#ifdef DEBUG
#if POSTPROCESS_DAT_FILES
static void add_missing_translation(const char *buffer);
static void postprocess_missing_translation();
static void clean_custom_translation();

struct MISSING_TRANSLATION
{
	char name[100];
	struct MISSING_TRANSLATION
		*pred,
		*succ;
};

typedef struct MISSING_TRANSLATION missing_translation;

static missing_translation *missing_list;
#endif
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const char
	*language_strings [] =
	{
		"ENGLISH",
		"FRENCH",
		"GERMAN",
		"ITALIAN",
		"SPANISH",
		"RUSSIAN",
		"POLISH",
	};

language_struct
	*alphabet_pointers [NUM_ALPHABET_POINTERS];

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static unsigned l2i(char ch)
{
	return isalpha(ch) ? toupper(ch) - 64 : 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

language_struct *initialise_translation (void)
{
	language_struct
		*new_;

	new_ = (language_struct*) safe_malloc (sizeof (language_struct));

	new_->tag = NULL;

	new_->translation = NULL;

	new_->next = NULL;

	return new_;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void insert_translation (language_struct *insert_me)
{
	unsigned
		index;

	index = l2i(insert_me->tag[0]);
	insert_me->next = alphabet_pointers[index];
	alphabet_pointers[index] = insert_me;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void delete_translation (language_struct *delete_me)
{
	if (delete_me->tag)
	{
		safe_free (delete_me->tag);
	}

	if (delete_me->translation)
	{
		safe_free (delete_me->translation);
	}

	safe_free (delete_me);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void initialise_language_file (FILE *fp)
{
	language_struct
		*lang;

	file_tags
		tag;

	char
		buf [BUFFER_SIZE];

	int
		lang_type,
		unicode = 0,
		end = 0;

	ASSERT (fp);

	// read entries
	while (!end)
	{
		tag = (file_tags) get_next_file_tag (fp, application_tag_strings, FILE_TAG_APPLICATION_LAST_TAG);

		switch (tag)
		{
			case FILE_TAG_START:
			{
				continue;
			}
			case FILE_TAG_UNICODE:
			{
				unicode = 1;
				continue;
			}
			case FILE_TAG_TRANSLATION:
			{
				// get tag & malloc char* array for translations
				if( get_next_file_string (fp, buf, BUFFER_SIZE) == 1)
				{
					lang = initialise_translation ();

					lang->tag = (char*) safe_malloc (strlen(buf) + 1);

					strcpy (lang->tag, buf);
				}
				else
				{
					debug_fatal("LANGUAGE: initialise: failed to acquire language tag");
				}

				// get enum until correct language is found
				lang_type = get_next_file_enum (fp, language_strings, NUM_LANGUAGES);

				while (lang_type != NUM_LANGUAGES)
				{
					if (lang_type == get_global_current_language ())
					{
						// if the string is present
						if( get_next_file_string (fp, buf, BUFFER_SIZE) == 1)
						{
							if (lang->translation)
							{
								safe_free (lang->translation);
							}
							if (unicode)
							{
								lang->translation = (char *) safe_malloc (strlen (buf) + 1);

								strcpy (lang->translation, buf);
							}
							else
							{
								lang->translation = string_to_utf8 (buf);
							}
						}
						else
						{
							debug_fatal("LANGUAGE: failed to acquire %s translation.", lang->tag);
						}
					}
					else
					{
						get_next_file_string (fp, buf, BUFFER_SIZE);
					}

					lang_type = get_next_file_enum (fp, language_strings, NUM_LANGUAGES);
				}

				end = FALSE;

				if (lang->translation)
				{
					insert_translation (lang);
				}

				break;
			}

			case FILE_TAG_TRANSLATION_PARAGRAPH:
			{
				// get tag & malloc char* array for translations
				if( get_next_file_string (fp, buf, BUFFER_SIZE) == 1)
				{
					lang = initialise_translation ();

					lang->tag = (char*) safe_malloc(strlen(buf) + 1);

					strcpy(lang->tag, buf);
				}
				else
				{
					debug_fatal("LANGUAGE: initialise: failed to acquire language tag");
				}

				// get enum until correct language is found
				lang_type = get_next_file_enum (fp, language_strings, NUM_LANGUAGES);

				while (lang_type != NUM_LANGUAGES)
				{

					if (lang_type == get_global_current_language ())
					{
						// if the string is present
						if( get_next_file_paragraph (fp, buf, BUFFER_SIZE) == 1)
						{
							if (lang->translation)
							{
								safe_free (lang->translation);
							}
							if (unicode)
							{
								lang->translation = (char*) safe_malloc(strlen(buf) + 1);

								strcpy(lang->translation, buf);
							}
							else
							{
								lang->translation = string_to_utf8 (buf);
							}

							fseek (fp, +1, SEEK_CUR);
						}
						else
						{
							debug_fatal("LANGUAGE: failed to acquire %s translation.", lang->tag);
						}
					}
					else
					{
						get_next_file_paragraph (fp, buf, BUFFER_SIZE);

						fseek (fp, +1, SEEK_CUR);
					}

					lang_type = get_next_file_enum (fp, language_strings, NUM_LANGUAGES);
				}

				end = FALSE;

				insert_translation (lang);

				break;
			}

			case FILE_TAG_END:
			{
				end = TRUE;
			}
		}
	}

	safe_fclose(fp);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void initialise_language_database (void)
{
	FILE
		*fp;

	directory_file_list
		*directory_listing;

	int
		valid_file;

	char
		directory_search_path[256];
	const char
		*filename;

	memset (alphabet_pointers, 0, NUM_ALPHABET_POINTERS);

	#if PREPROCESS_DAT_FILES
		preprocess_language_database ();
	#endif

	// ensure current selected language is allowed

	if ((global_options.current_language < 0) || (global_options.current_language >= NUM_LANGUAGES))
	{
		set_current_language (LANGUAGE_ENGLISH);
	}

	sprintf (directory_search_path, "%s\\*.dat", LANGUAGE_DIRECTORY);

	directory_listing = get_first_directory_file ( directory_search_path );

	// JB 030313 Enable running out of separate directories
	if (!directory_listing)
	{
		char fn[1024];
		fn[0] = 0;
		strcpy(fn, comanche_hokum_installation_path);
		strcat(fn, "\\common\\");
		strcat(fn, directory_search_path);

		directory_listing = get_first_directory_file ( fn );
	}

	ASSERT (directory_listing);

	valid_file = TRUE;

	while ( valid_file )
	{
		if ( get_directory_file_type ( directory_listing ) == DIRECTORY_FILE_TYPE_FILE )
		{
			filename = get_directory_file_filename ( directory_listing );

			sprintf ( full_filename, "%s\\%s", LANGUAGE_DIRECTORY, filename );

			debug_log ( "Processing language file %s", full_filename );

			fp = safe_fopen (full_filename, "r");

			initialise_language_file (fp);
		}

		valid_file = get_next_directory_file ( directory_listing );
	}

	destroy_directory_file_list ( directory_listing );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const char *get_trans (const char *string)
{
	language_struct
		*temp;

	const char
		*result;

	for (temp = alphabet_pointers [l2i(string[0])]; temp; temp = temp->next)
	{
		if (strcmp(temp->tag, string) == 0)
		{
			result = temp->translation;
			break;
		}
	}

	if (!temp)
	{
		int
			unicode = 1,
			count;

		for (count = 0; string[count]; count++)
		{
			unsigned char
				ch;

			ch = string[count];
			if (ch < 0x80)
			{
				continue;
			}
			if ((ch & 0xE0) == 0xC0)
			{
				count++;
				ch = string[count];
				if ((ch & 0xC0) == 0x80)
				{
					continue;
				}
			}

			unicode = 0;
			break;
		}

		if (unicode)
		{
			result = string;
		}
		else
		{
			temp = initialise_translation ();
			temp->tag = (char*) safe_malloc (strlen(string) + 1);
			strcpy (temp->tag, string);
			temp->translation = string_to_utf8 (string);
			insert_translation (temp);
			result = temp->translation;
		}

		#if DEBUG_MODULE

			debug_fatal("LANGUAGE.C: %s not found in translation database", string);
		#elif DEBUG_LANGUAGES

			debug_filtered_log ("LANGUAGE.C: get_trans() couldn't find: %s", string);

		#endif

		#ifdef DEBUG
		#if POSTPROCESS_DAT_FILES
			add_missing_translation(result);
		#endif
		#endif
	}

	return result;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void deinitialise_language_database (void)
{
	language_struct
		*temp;

	int
		count;

	for (count = 0; count < ARRAYSIZE(alphabet_pointers); count++)
	{
		while ((temp = alphabet_pointers[count]))
		{
			alphabet_pointers[count] = alphabet_pointers[count]->next;
			delete_translation (temp);
		}
	}

	#ifdef DEBUG
	#if POSTPROCESS_DAT_FILES
		postprocess_missing_translation();
	#endif
	#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void set_current_language (int language)
{
	if ((language >= LANGUAGE_ENGLISH) && ( language < NUM_LANGUAGES))
	{
		global_options.current_language = language;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int get_next_file_translation (FILE *file_ptr, char *buffer, int size)
{

	char
		temp [BUFFER_SIZE];

	int
		i,
		start,
		character,
		count;

	memset (temp, 0, size);
	memset (buffer, 0, size);

	count = 0;

	// get the text

	while (((character = fgetc (file_ptr)) != EOF) && (count < BUFFER_SIZE))
	{
		// copy to next tab - but ignore leading white space inc. tabs (ASCII value 9)

		if ((character == '\t') || (character == ':'))
		{
			while ((character = fgetc (file_ptr)) == '\t')
			{
			}

			fseek (file_ptr, -1, SEEK_CUR);

			break;
		}

		temp [count++] = character;
	}

	// get length and start (after white space) of string

	count = strlen (temp) - 1;

	for (i = 0; i <= count; i++)
	{
		if ((temp [i] != ' ') || (temp [i] != '\t'))
		{
			start = i;

			break;
		}
	}

	// remove leading and trailing white space - including tabs (ASCII value 9)

	for (i = count; i >= start; i--)
	{
		if (! ((temp [i] == ' ') || (temp [i] == '\t')) )
		{
			int
				j;

			for (j = i; j >= 0; j--)
			{
				buffer [j] = temp [j];
			}

			break;
		}
	}

	strcat (buffer, "\n");

	#if DEBUG_MODULE
		debug_filtered_log ("FILE_TAG: get_next_file_translation = %s, strlen (%d)", buffer, strlen (buffer));
	#endif

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void preprocess_language_file (FILE *fp, FILE *fp_out)
{
	file_tags
		tag;

	char
		buffer [BUFFER_SIZE];

	int
		count = 0,
		lang_type,
		lang_count,
		end = FALSE;

	ASSERT (fp);

	// read entries
	while (!end)
	{
		tag = (file_tags) get_next_file_tag (fp, application_tag_strings, FILE_TAG_APPLICATION_LAST_TAG);

		switch (tag)
		{
			case FILE_TAG_START:
			{
				fprintf (fp_out, ":START\n\n");

				break;
			}
			case FILE_TAG_TRANSLATION:
			{
				fprintf (fp_out, "\n:TRANSLATION ");

				// get tag for translations
				if( get_next_file_translation (fp, buffer, BUFFER_SIZE) == TRUE)
				{
					fprintf (fp_out, buffer);
				}
				else
				{
					debug_fatal("PRE_LANG: initialise: failed to acquire language tag");
				}

				for (lang_count = LANGUAGE_ENGLISH; lang_count < NUM_LANGUAGES; lang_count++)
				{
					lang_type = get_next_file_enum (fp, language_strings, NUM_LANGUAGES);

					set_file_enum (fp_out, language_strings, lang_type);

					if (get_next_file_translation (fp, buffer, BUFFER_SIZE) == TRUE)
					{
						fprintf (fp_out, buffer);
					}
					else
					{
						debug_fatal("PRE_LANG: failed to acquire %s translation.", buffer);
					}
				}

				count++;

				break;
			}

			case FILE_TAG_TRANSLATION_PARAGRAPH:
			{
				fprintf (fp_out, "\n:TRANSLATION_PARAGRAPH ");

				// get tag for translations
				if( get_next_file_translation (fp, buffer, BUFFER_SIZE) == TRUE)
				{
					fprintf (fp_out, buffer);
				}
				else
				{
					debug_fatal("PRE_LANG: initialise: failed to acquire language tag");
				}

				for (lang_count = LANGUAGE_ENGLISH; lang_count < NUM_LANGUAGES; lang_count++)
				{
					// get enum
					lang_type = get_next_file_enum (fp, language_strings, NUM_LANGUAGES);

					set_file_enum (fp_out, language_strings, lang_type);

					if (get_next_file_translation (fp, buffer, BUFFER_SIZE) == TRUE)
					{
						fprintf (fp_out, buffer);
						fprintf (fp_out, ":");
					}
					else
					{
						debug_fatal("PRE_LANG: failed to acquire %s translation.", buffer);
					}
				}

				count++;

				break;
			}

			case FILE_TAG_END:
			{
				end = TRUE;

				fprintf (fp_out, "\n:END\n\n");

				break;
			}

			default:
			{
				debug_fatal ("LANGUAGE.C: tag not matched!");
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void preprocess_language_database (void)
{
	FILE
		*fp,
		*fp_out;

	directory_file_list
		*directory_listing;

	int
		count = 0,
		valid_file;

	char
		directory_search_path [256],
		full_filename [256],
		output_filename [256];
	const char
		*filename;

	sprintf (directory_search_path, "%s\\*.txt", LANGUAGE_DIRECTORY);

	directory_listing = get_first_directory_file (directory_search_path);

	ASSERT (directory_listing);

	valid_file = TRUE;

	while (valid_file)
	{
		if (get_directory_file_type (directory_listing) == DIRECTORY_FILE_TYPE_FILE)
		{
			filename = get_directory_file_filename (directory_listing);

			sprintf (full_filename, "%s\\%s", LANGUAGE_DIRECTORY, filename);

			sprintf (output_filename, "%s\\tlate%d.dat", LANGUAGE_DIRECTORY, count);

			debug_filtered_log ("Processing language file %s", full_filename);

			fp = safe_fopen (full_filename, "r");

			fp_out = safe_fopen (output_filename, "w");

			preprocess_language_file (fp, fp_out);

			safe_fclose(fp);

			safe_fclose(fp_out);

			count++;
		}
		valid_file = get_next_directory_file ( directory_listing );
	}
	destroy_directory_file_list ( directory_listing );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

font_types get_current_language_font (font_types font)
{
	if (get_global_current_language () == LANGUAGE_RUSSIAN)
	{
		switch (font)
		{
			case UI_FONT_ARIAL_10:
					return UI_FONT_ARIAL_10;

			case UI_FONT_ARIAL_14:
					return UI_FONT_ARIAL_10;

			case UI_FONT_ITALIC_ARIAL_14:
					return UI_FONT_ARIAL_10;

			case UI_FONT_ARIAL_16:
					return UI_FONT_ARIAL_10;

			case UI_FONT_ITALIC_ARIAL_16:
					return UI_FONT_ARIAL_10;

			default:
					return font;
		}
	}

	return font;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG
#if POSTPROCESS_DAT_FILES
static void postprocess_missing_translation() {
	int i = 0;
	FILE *fp_out;

	if ( missing_list )
	{
		missing_translation
			*this_string = NULL,
			*last_string = NULL;

		this_string = missing_list;

		fp_out = safe_fopen (full_filename, "a");
		
		while ( this_string )
		{
			debug_log("Missing translation: %s", this_string->name);

			if (fp_out != NULL) {
				fprintf (fp_out, ":TRANSLATION ");
				fprintf (fp_out, &this_string->name);
				fprintf (fp_out, "\n");

				for (i = 0; i < 7; i++) {
					fprintf (fp_out, language_strings[i]);
					fprintf (fp_out, " ");
					fprintf (fp_out, &this_string->name);
					fprintf (fp_out, "\n");		
				}

				fprintf (fp_out, "\n\n");
			}

			if (last_string != NULL) {
				safe_free ( last_string );
			}
			last_string = this_string;
			this_string = this_string->succ;
		}

		safe_fclose(fp_out);
	}
	
	missing_list = NULL;
}

static void add_missing_translation(const char *buffer) {
	missing_translation *string;

	string = ( missing_translation * ) safe_malloc ( sizeof ( missing_translation ) );
	strncpy(string->name, buffer, 100);
	//string->name[99] = '\0';

	if ( missing_list )
	{
		missing_translation
			*this_string,
			*last_string;

		this_string = missing_list;

		while ( this_string )
		{
			if (strcmp(this_string->name, string->name) == 0) {
				safe_free ( string );
				return;
			}
			
			last_string = this_string;
			this_string = this_string->succ;
		}

		string->pred = last_string;
		string->succ = NULL;

		last_string->succ = string;
	}
	else
	{
		string->pred = NULL;
		string->succ = NULL;
		missing_list = string;
	}	
}

#endif
#endif

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
