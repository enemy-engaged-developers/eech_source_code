// 
// 	 Enemy Engaged RAH-66 Comanche Versus KA-52 Hokum
// 	 Copyright (C) 2000 Empire Interactive (Europe) Ltd,
// 	 677 High Road, North Finchley, London N12 0DA
// 
// 	 Please see the document LICENSE.TXT for the full licence agreement
// 
// 2. LICENCE
//  2.1 	
//  	Subject to the provisions of this Agreement we now grant to you the 
//  	following rights in respect of the Source Code:
//   2.1.1 
//   	the non-exclusive right to Exploit  the Source Code and Executable 
//   	Code on any medium; and 
//   2.1.2 
//   	the non-exclusive right to create and distribute Derivative Works.
//  2.2 	
//  	Subject to the provisions of this Agreement we now grant you the
// 	following rights in respect of the Object Code:
//   2.2.1 
// 	the non-exclusive right to Exploit the Object Code on the same
// 	terms and conditions set out in clause 3, provided that any
// 	distribution is done so on the terms of this Agreement and is
// 	accompanied by the Source Code and Executable Code (as
// 	applicable).
// 
// 3. GENERAL OBLIGATIONS
//  3.1 
//  	In consideration of the licence granted in clause 2.1 you now agree:
//   3.1.1 
// 	that when you distribute the Source Code or Executable Code or
// 	any Derivative Works to Recipients you will also include the
// 	terms of this Agreement;
//   3.1.2 
// 	that when you make the Source Code, Executable Code or any
// 	Derivative Works ("Materials") available to download, you will
// 	ensure that Recipients must accept the terms of this Agreement
// 	before being allowed to download such Materials;
//   3.1.3 
// 	that by Exploiting the Source Code or Executable Code you may
// 	not impose any further restrictions on a Recipient's subsequent
// 	Exploitation of the Source Code or Executable Code other than
// 	those contained in the terms and conditions of this Agreement;
//   3.1.4 
// 	not (and not to allow any third party) to profit or make any
// 	charge for the Source Code, or Executable Code, any
// 	Exploitation of the Source Code or Executable Code, or for any
// 	Derivative Works;
//   3.1.5 
// 	not to place any restrictions on the operability of the Source 
// 	Code;
//   3.1.6 
// 	to attach prominent notices to any Derivative Works stating
// 	that you have changed the Source Code or Executable Code and to
// 	include the details anddate of such change; and
//   3.1.7 
//   	not to Exploit the Source Code or Executable Code otherwise than
// 	as expressly permitted by  this Agreement.
// 



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "project.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//note: 	when converting data from .txt files generated by excel, turn PREPROCESS_DAT_FILES & DEBUG_MODULE on
//			when using new translation material for the first time, turn DEBUG_LANGUAGES on

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define BUFFER_SIZE 8192

#define DEBUG_MODULE 0

#define PREPROCESS_DAT_FILES 0

#define DEBUG_LANGUAGES 1

#define NUM_ALPHABET_POINTERS 28

#define LANGUAGE_DIRECTORY "..\\common\\data\\language"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void initialise_alphabet_pointers (void);

static language_struct *initialise_translation (void);

static void insert_translation (language_struct *insert_me);

static void delete_translation (language_struct *position, language_struct *delete_me);

static void initialise_language_file (FILE *fp);

static void validate_translation_database (void);

static int get_next_file_translation (FILE *file_ptr, char *buffer, int size);

#if DEBUG_LANGUAGES
	static void test_translation_list (void);
#endif

#if PREPROCESS_DAT_FILES
	static void preprocess_language_file (FILE *fp, FILE *fp_out);

	static void preprocess_language_database (void);
#endif

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const char
	*language_strings [] =
	{
		"ENGLISH",
		"FRENCH",
		"GERMAN",
		"ITALIAN",
		"SPANISH",
		"RUSSIAN",
		"POLISH",
	};
	
language_struct
	*translation_list,
	*alphabet_pointers [NUM_ALPHABET_POINTERS];

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void initialise_alphabet_pointers (void)
{
	language_struct
		*current;

	char
		a,
		letter;

	int
		count;

	ASSERT (translation_list);
	
	current = translation_list;

	memset (alphabet_pointers, 0, NUM_ALPHABET_POINTERS);

	// set 1st pointer to 1st of misc. characters
	a = current->tag [0];

	if ((toupper (a) < 'A') || (toupper (a) > 'Z'))
	{
		alphabet_pointers [0] = translation_list;
	}
		
	current = current->next;

	count = 1;
	
	letter = 'A';

	// get alphabet pointers
	while (current)
	{
		a = toupper (current->tag [0]);

		if (a == toupper (letter))
		{
			letter++;
			
			alphabet_pointers [letter - 'A'] = current;
		}
		// in case there are no translations for current letter, move on.
		else if (a > toupper (letter))
		{
			letter = a + 1;

			alphabet_pointers [letter - 'A'] = current;
		}

		current = current->next;

		count++;
	}

	alphabet_pointers [NUM_ALPHABET_POINTERS - 1] = NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

language_struct *initialise_translation (void)
{
	language_struct
		*new_;

	new_ = (language_struct*) safe_malloc (sizeof (language_struct));

	new_->tag = NULL;

	new_->translation = NULL;

	new_->next = NULL;

	return new_;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void insert_translation (language_struct *insert_me)
{
	language_struct
		*previous,
		*current;

	previous = NULL;

	current = translation_list;

	if (current != NULL)
	{
		while ((current != NULL) && (stricmp (insert_me->tag, current->tag) > 0))
		{
			previous = current;
			
			current = current->next;
		}

		// do not insert duplicate translations
		if (current != NULL)
		{
			if (strcmp (insert_me->tag, current->tag) == 0)
			{
				if (strcmp (insert_me->translation, current->translation) != 0)
				{
					#if DEBUG_LANGUAGES
						debug_filtered_log ("WARNING: translation with same tags & different translations");
						
						debug_filtered_log ("old: %s  :  %s", current->tag, current->translation);
	
						debug_filtered_log ("new: %s  :  %s", insert_me->tag, insert_me->translation);
					#endif
				}
				else
				{
					#if DEBUG_LANGUAGES
						debug_filtered_log ("WARNING: deleting duplicate translation");
					#endif
	
					delete_translation (NULL, insert_me);
					
					return;				
				}
			}
		}
		
		insert_me->next = current;

		if (previous != NULL)
		{
			previous->next = insert_me;
		}
		else
		{
			translation_list = insert_me;
		}
	}
	else
	{
		translation_list = insert_me;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void delete_translation (language_struct *position, language_struct *delete_me)
{
	if (position != NULL)
	{
		position->next = delete_me->next;
	}
	
	if (delete_me->tag)
	{
		safe_free (delete_me->tag);
	}

	if (delete_me->translation)
	{
		safe_free (delete_me->translation);
	}

	safe_free (delete_me);

	delete_me = NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void initialise_language_file (FILE *fp)
{
	language_struct
		*lang;

	file_tags
		tag;
		
	char
		buf [BUFFER_SIZE];
				
	int
		lang_type,
		end = 0;
		
	ASSERT (fp);

	// read entries
	while (!end)
	{
		tag = (file_tags) get_next_file_tag (fp, application_tag_strings, FILE_TAG_APPLICATION_LAST_TAG);

		switch (tag)
		{	
			case FILE_TAG_START:
			{		
				continue;
			}
			case FILE_TAG_TRANSLATION:
			{
				// get tag & malloc char* array for translations
				if( get_next_file_string (fp, buf, BUFFER_SIZE) == 1)
				{
					lang = initialise_translation ();

					lang->tag = (char*) safe_malloc( sizeof(char) * (strlen(buf) + 1) );

					strcpy(lang->tag, buf);
				}
				else
				{
					debug_fatal("LANGUAGE: initialise: failed to acquire language tag");
				}
				
				// get enum until correct language is found
				lang_type = get_next_file_enum (fp, language_strings, NUM_LANGUAGES);

				while (lang_type != NUM_LANGUAGES)
				{
					if (lang_type == get_global_current_language ())
					{
						// if the string is present
						if( get_next_file_string (fp, buf, BUFFER_SIZE) == 1)
						{
							lang->translation = (char*) safe_malloc(sizeof(char) * (strlen(buf) +1) );
		
							strcpy(lang->translation, buf);
						}
						else
						{
							debug_fatal("LANGUAGE: failed to acquire %s translation.", lang->tag);
						}
					}
					else
					{
						get_next_file_string (fp, buf, BUFFER_SIZE);
					}

					lang_type = get_next_file_enum (fp, language_strings, NUM_LANGUAGES);
				}

				end = FALSE;

				if (lang->translation)
				{
					insert_translation (lang);
				}

				break;
			}

			case FILE_TAG_TRANSLATION_PARAGRAPH:
			{
				// get tag & malloc char* array for translations
				if( get_next_file_string (fp, buf, BUFFER_SIZE) == 1)
				{
					lang = initialise_translation ();

					lang->tag = (char*) safe_malloc( sizeof(char) * (strlen(buf) + 1) );

					strcpy(lang->tag, buf);
				}
				else
				{
					debug_fatal("LANGUAGE: initialise: failed to acquire language tag");
				}
				
				// get enum until correct language is found
				lang_type = get_next_file_enum (fp, language_strings, NUM_LANGUAGES);

				while (lang_type != NUM_LANGUAGES)
				{

					if (lang_type == get_global_current_language ())
					{
						// if the string is present
						if( get_next_file_paragraph (fp, buf, BUFFER_SIZE) == 1)
						{
							lang->translation = (char*) safe_malloc(sizeof(char) * (strlen(buf) +1) );
		
							strcpy(lang->translation, buf);
		
							fseek (fp, +1, SEEK_CUR);
						}
						else
						{
							debug_fatal("LANGUAGE: failed to acquire %s translation.", lang->tag);
						}
					}
					else
					{
						get_next_file_paragraph (fp, buf, BUFFER_SIZE);
	
						fseek (fp, +1, SEEK_CUR);
					}
						
					lang_type = get_next_file_enum (fp, language_strings, NUM_LANGUAGES);
				}

				end = FALSE;

				insert_translation (lang);

				break;
			}

			case FILE_TAG_END:
			{
				end = TRUE;
			}
		}
	}

	safe_fclose(fp);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void initialise_language_database (void)
{
	FILE
		*fp;
		
	directory_file_list
		*directory_listing;

	int
		valid_file;

	char
		directory_search_path[256],
		full_filename[256];
	const char
		*filename;

	translation_list = NULL;

	memset (alphabet_pointers, 0, NUM_ALPHABET_POINTERS);

	#if PREPROCESS_DAT_FILES
		preprocess_language_database ();
	#endif
	
	// ensure current selected language is allowed

	if ((global_options.current_language < 0) || (global_options.current_language >= NUM_LANGUAGES))
	{
		set_current_language (LANGUAGE_ENGLISH);
	}

	sprintf (directory_search_path, "%s\\*.dat", LANGUAGE_DIRECTORY);

	directory_listing = get_first_directory_file ( directory_search_path );

	// JB 030313 Enable running out of separate directories
	if (!directory_listing)
	{
		char fn[1024];
		fn[0] = 0;
		strcpy(fn, comanche_hokum_installation_path);
		strcat(fn, "\\common\\");
		strcat(fn, directory_search_path);

		directory_listing = get_first_directory_file ( fn );
	}

	ASSERT (directory_listing);

	valid_file = TRUE;

	while ( valid_file )
	{
		if ( get_directory_file_type ( directory_listing ) == DIRECTORY_FILE_TYPE_FILE )
		{
			filename = get_directory_file_filename ( directory_listing );

			sprintf ( full_filename, "%s\\%s", LANGUAGE_DIRECTORY, filename );

			debug_log ( "Processing language file %s", full_filename );

			fp = safe_fopen (full_filename, "r");

			initialise_language_file (fp);
		}

		valid_file = get_next_directory_file ( directory_listing );
	}

	destroy_directory_file_list ( directory_listing );

	initialise_alphabet_pointers ();

	#if DEBUG_LANGUAGES
		test_translation_list ();
	#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const char *get_trans (const char *string)
{
	language_struct
		*temp;
		
	const char
		*result = NULL;
		
	int
		not_found,
		start,
		end;
		
	if (isalpha (string [0]))
	{
		start = toupper (string [0]) - 64;
	}
	else
	{
		start = 0;
	}

	end = start + 1;

	ASSERT (end < NUM_ALPHABET_POINTERS);

	temp = alphabet_pointers [start];

	not_found = 1;

	if (temp != NULL)
	{
		while ((not_found) && (temp != alphabet_pointers [end]))
		{
			if( strcmp(temp->tag, string) == 0)
			{
				result = temp->translation;
		
				not_found = 0;
			}
	
			temp = temp->next;
		}
	}

	if(result == NULL)
	{
		result = string;

		#if DEBUG_MODULE

			debug_fatal("LANGUAGE.C: %s not found in translation database", string);
		#elif DEBUG_LANGUAGES

			debug_filtered_log ("LANGUAGE.C: get_trans() couldn't find: %s", string);

		#endif		
	}	

	return result;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void deinitialise_language_database (void)
{
	language_struct
		*temp;

	while (translation_list)
	{
		temp = translation_list->next;
	
		delete_translation (NULL, translation_list);

		translation_list = temp;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void set_current_language (int language)
{
	if ((language >= LANGUAGE_ENGLISH) && ( language < NUM_LANGUAGES))
	{
		global_options.current_language = language;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void test_translation_list (void)
{
	language_struct
		*temp;
		
	int
		alphabet_count = 0,
		count = 0;

	temp = translation_list;

	while (temp != NULL)
	{
		if (alphabet_pointers [alphabet_count] == temp)
		{
			debug_filtered_log ("\n~~~ ALPHABET_POINTER  %c ~~~\n", (alphabet_count + 64));
	
			alphabet_count++;
		}

		debug_filtered_log ("%3d:  %s  :  %s", count, temp->tag, temp->translation);
		
		temp = temp->next;

		count++;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int get_next_file_translation (FILE *file_ptr, char *buffer, int size)
{

	char
		temp [BUFFER_SIZE];
		
	int
		i,
		start,
		character,
		count;

	memset (temp, 0, size);
	memset (buffer, 0, size);

	count = 0;

	// get the text

	while (((character = fgetc (file_ptr)) != EOF) && (count < BUFFER_SIZE))
	{
		// copy to next tab - but ignore leading white space inc. tabs (ASCII value 9)

		if ((character == '\t') || (character == ':'))
		{
			while ((character = fgetc (file_ptr)) == '\t')
			{
			}

			fseek (file_ptr, -1, SEEK_CUR);

			break;
		}
		
		temp [count++] = character;
	}

	// get length and start (after white space) of string

	count = strlen (temp) - 1;

	for (i = 0; i <= count; i++)
	{
		if ((temp [i] != ' ') || (temp [i] != '\t'))
		{
			start = i;

			break;
		}
	}

	// remove leading and trailing white space - including tabs (ASCII value 9)

	for (i = count; i >= start; i--)
	{
		if (! ((temp [i] == ' ') || (temp [i] == '\t')) )
		{
			int
				j;

			for (j = i; j >= 0; j--)
			{
				buffer [j] = temp [j];
			}
			
			break;
		}
	}	
	
	strcat (buffer, "\n");
	
	#if DEBUG_MODULE
		debug_filtered_log ("FILE_TAG: get_next_file_translation = %s, strlen (%d)", buffer, strlen (buffer));
	#endif

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void preprocess_language_file (FILE *fp, FILE *fp_out)
{
	file_tags
		tag;
		
	char
		buffer [BUFFER_SIZE];
				
	int
		count = 0,
		lang_type,
		lang_count,
		end = FALSE;
		
	ASSERT (fp);

	// read entries
	while (!end)
	{
		tag = (file_tags) get_next_file_tag (fp, application_tag_strings, FILE_TAG_APPLICATION_LAST_TAG);

		switch (tag)
		{	
			case FILE_TAG_START:
			{
				fprintf (fp_out, ":START\n\n");

				break;
			}
			case FILE_TAG_TRANSLATION:
			{
				fprintf (fp_out, "\n:TRANSLATION ");

				// get tag for translations
				if( get_next_file_translation (fp, buffer, BUFFER_SIZE) == TRUE)
				{
					fprintf (fp_out, buffer);
				}
				else
				{
					debug_fatal("PRE_LANG: initialise: failed to acquire language tag");
				}

				for (lang_count = LANGUAGE_ENGLISH; lang_count < NUM_LANGUAGES; lang_count++)
				{
					lang_type = get_next_file_enum (fp, language_strings, NUM_LANGUAGES);

					set_file_enum (fp_out, language_strings, lang_type);

					if (get_next_file_translation (fp, buffer, BUFFER_SIZE) == TRUE)
					{
						fprintf (fp_out, buffer);
					}
					else
					{
						debug_fatal("PRE_LANG: failed to acquire %s translation.", buffer);
					}
				}

				count++;

				break;
			}

			case FILE_TAG_TRANSLATION_PARAGRAPH:
			{
				fprintf (fp_out, "\n:TRANSLATION_PARAGRAPH ");

				// get tag for translations
				if( get_next_file_translation (fp, buffer, BUFFER_SIZE) == TRUE)
				{
					fprintf (fp_out, buffer);
				}
				else
				{
					debug_fatal("PRE_LANG: initialise: failed to acquire language tag");
				}

				for (lang_count = LANGUAGE_ENGLISH; lang_count < NUM_LANGUAGES; lang_count++)
				{
					// get enum
					lang_type = get_next_file_enum (fp, language_strings, NUM_LANGUAGES);

					set_file_enum (fp_out, language_strings, lang_type);

					if (get_next_file_translation (fp, buffer, BUFFER_SIZE) == TRUE)
					{
						fprintf (fp_out, buffer);
						fprintf (fp_out, ":");
					}
					else
					{
						debug_fatal("PRE_LANG: failed to acquire %s translation.", buffer);
					}
				}

				count++;

				break;
			}

			case FILE_TAG_END:
			{
				end = TRUE;

				fprintf (fp_out, "\n:END\n\n");

				break;
			}

			default:
			{
				debug_fatal ("LANGUAGE.C: tag not matched!");
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void preprocess_language_database (void)
{
	FILE
		*fp,
		*fp_out;
		
	directory_file_list
		*directory_listing;

	int
		count = 0,
		valid_file;

	char
		directory_search_path [256],
		full_filename [256],
		output_filename [256];
	const char
		*filename;

	sprintf (directory_search_path, "%s\\*.txt", LANGUAGE_DIRECTORY);

	directory_listing = get_first_directory_file (directory_search_path);

	ASSERT (directory_listing);

	valid_file = TRUE;

	while (valid_file)
	{
		if (get_directory_file_type (directory_listing) == DIRECTORY_FILE_TYPE_FILE)
		{
			filename = get_directory_file_filename (directory_listing);

			sprintf (full_filename, "%s\\%s", LANGUAGE_DIRECTORY, filename);

			sprintf (output_filename, "%s\\tlate%d.dat", LANGUAGE_DIRECTORY, count);

			debug_filtered_log ("Processing language file %s", full_filename);

			fp = safe_fopen (full_filename, "r");

			fp_out = safe_fopen (output_filename, "w");

			preprocess_language_file (fp, fp_out);

			safe_fclose(fp);

			safe_fclose(fp_out);

			count++;
		}
		valid_file = get_next_directory_file ( directory_listing );
	}
	destroy_directory_file_list ( directory_listing );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

font_types get_current_language_font (font_types font)
{
	if (get_global_current_language () == LANGUAGE_RUSSIAN)
	{
		switch (font)
		{
			case UI_FONT_ARIAL_10:
					return UI_FONT_ARIAL_10;

			case UI_FONT_ARIAL_14:
					return UI_FONT_ARIAL_10;

			case UI_FONT_ITALIC_ARIAL_14:
					return UI_FONT_ARIAL_10;

			case UI_FONT_ARIAL_16:
					return UI_FONT_ARIAL_10;

			case UI_FONT_ITALIC_ARIAL_16:
					return UI_FONT_ARIAL_10;

			default:
					return font;
		}
	}

	return font;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


